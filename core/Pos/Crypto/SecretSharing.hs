{-| An implementation of VSS (wrapping over pvss).
    For more details see <https://github.com/input-output-hk/pvss-haskell>.
-}

module Pos.Crypto.SecretSharing
       ( -- * Keys and related.
         VssPublicKey (..)
       , VssKeyPair (..)
       , toVssPublicKey
       , vssKeyGen
       , deterministicVssKeyGen

         -- * Sharing
       , Scrape.DhSecret (..)
       , EncShare (..)
       , Secret (..)
       , SecretProof (..)
       , DecShare (..)
       , Scrape.Threshold

       , decryptShare
       , getDhSecret
       , genSharedSecret
       , recoverSecret
       , secretToDhSecret
       , verifyEncShares
       , verifyDecShare
       , verifySecret
       ) where

import           Universum

import           Crypto.Random       (MonadRandom)
import qualified Crypto.SCRAPE       as Scrape
import qualified Data.Binary         as Binary
import           Data.Coerce
import           Data.Hashable       (Hashable (hashWithSalt))
import           Data.HashMap.Strict (HashMap)
import qualified Data.HashMap.Strict as HM
import           Data.Text.Buildable (Buildable)
import qualified Data.Text.Buildable as Buildable
import           Formatting          (bprint, (%))

import           Pos.Binary.Class    (Bi, encode)
import           Pos.Crypto.Hashing  (hash, shortHashF)
import           Pos.Crypto.Random   (deterministic, runSecureRandom)

----------------------------------------------------------------------------
-- Keys
----------------------------------------------------------------------------

-- | This key is used as public key in VSS.
newtype VssPublicKey = VssPublicKey
    { getVssPublicKey :: Scrape.PublicKey
    } deriving (Show, Eq, Binary.Binary)

-- | Note: this is an important instance, don't change it! It dictates the
-- order of participants when generating a commitment.
instance Ord VssPublicKey where
    compare = comparing Binary.encode

instance Hashable VssPublicKey where
    hashWithSalt s = hashWithSalt s . Binary.encode

-- | This key pair is used to decrypt share generated by VSS.
newtype VssKeyPair =
    VssKeyPair Scrape.KeyPair
    deriving (Show, Eq, Generic)

instance (Bi VssKeyPair) => Buildable VssKeyPair where
    build = bprint ("vsssec:"%shortHashF) . hash

-- | Extract VssPublicKey from VssKeyPair.
toVssPublicKey :: VssKeyPair -> VssPublicKey
toVssPublicKey (VssKeyPair pair) = VssPublicKey $ Scrape.toPublicKey pair

-- | Generate VssKeyPair using Really Secureâ„¢ randomness.
vssKeyGen :: MonadIO m => m VssKeyPair
vssKeyGen = VssKeyPair <$> liftIO (runSecureRandom Scrape.keyPairGenerate)

-- | Generate VssKeyPair using given seed.
deterministicVssKeyGen :: ByteString -> VssKeyPair
deterministicVssKeyGen seed =
    VssKeyPair $ deterministic seed Scrape.keyPairGenerate

----------------------------------------------------------------------------
-- Types
----------------------------------------------------------------------------

-- | Secret can be generated by 'genSharedSecret' function along with shares.
newtype Secret = Secret
    { getSecret :: Scrape.Secret
    } deriving (Show, Eq)

-- | Shares can be used to reconstruct 'Secret'.
newtype DecShare = DecShare
    { getDecShare :: Scrape.DecryptedShare
    } deriving (Show, Eq)

-- | Encrypted share which needs to be decrypted using 'VssKeyPair' first.
newtype EncShare = EncShare
    { getEncShareVal :: Scrape.EncryptedSi
    } deriving (Show, Eq)

-- | This extra data may be used to verify various stuff.
data SecretProof = SecretProof
    { spExtraGen       :: !Scrape.ExtraGen
    , spProof          :: !Scrape.Proof
    , spParallelProofs :: !Scrape.ParallelProofs
    , spCommitments    :: ![Scrape.Commitment]
    } deriving (Show, Eq, Generic)

instance Bi SecretProof => Hashable SecretProof where
    hashWithSalt s = hashWithSalt s . encode

----------------------------------------------------------------------------
-- Functions
----------------------------------------------------------------------------

-- | Extract ByteString from DhSecret.
getDhSecret :: Scrape.DhSecret -> ByteString
getDhSecret (Scrape.DhSecret s) = s

-- | Transform a Secret into a usable random value.
secretToDhSecret :: Secret -> Scrape.DhSecret
secretToDhSecret = Scrape.secretToDhSecret . getSecret

-- | Decrypt share using secret key. Doesn't verify if an encrypted
-- share is valid, for this you need to use verifyEncShare.
decryptShare
    :: MonadRandom m
    => VssKeyPair -> EncShare -> m DecShare
decryptShare (VssKeyPair k) (EncShare encShare) =
    DecShare <$> Scrape.shareDecrypt k encShare

-- | Generate random secret using MonadRandom and share it between
-- given public keys.
genSharedSecret
    :: MonadRandom m
    => Scrape.Threshold
    -> NonEmpty VssPublicKey
    -> m (Secret, SecretProof, [EncShare])
genSharedSecret t ps
    | t <= 1     = error "genSharedSecret: threshold must be > 1"
    | t >= n - 1 = error "genSharedSecret: threshold must be < n-1"
    | otherwise  = convertRes <$> Scrape.escrow t (coerce (toList ps))
  where
    n = fromIntegral (length ps)
    convertRes (gen, secret, shares, comms, proof, pproofs) =
        (coerce secret, SecretProof gen proof pproofs comms, coerce shares)

-- | Recover secret if there are enough correct shares.
--
-- You *must* perform these checks on earlier stages:
--
--   * There are as many decrypted shares as there are encrypted shares for
--     each participant.
--
--   * All shares are decrypted correctly (use 'verifyDecShare' for that)
--
recoverSecret
    :: Scrape.Threshold
    -> [(VssPublicKey, Int)]            -- ^ Participants (their order is
                                        --    important) + how many shares
                                        --    were sent to each
    -> HashMap VssPublicKey [DecShare]  -- ^ Shares decrypted and returned by
                                        --    some participants
    -> Maybe Secret
recoverSecret (fromIntegral -> thr) participants shares = do
    -- We reorder the shares so that 'recover' can consume them
    let ordered :: [(Scrape.ShareId, DecShare)]
        ordered = reorderDecryptedShares participants shares
    -- Then we check that we have enough shares and do secret recovery
    guard (length ordered >= thr)
    pure (coerce Scrape.recover (take thr ordered))

-- | Like 'Scrape.reorderDecryptedShares', but handles the case when multiple
-- shares were created for a single key.
--
-- TODO: move to pvss-haskell, maybe
reorderDecryptedShares
    :: [(VssPublicKey, Int)]            -- ^ Participants
    -> HashMap VssPublicKey [DecShare]  -- ^ Decrypted shares
    -> [(Scrape.ShareId, DecShare)]
reorderDecryptedShares participants shares =
    map (first toInteger) $ go 1 participants
  where
    go :: Int                        -- ^ Index of current share
       -> [(VssPublicKey, Int)]      -- ^ Remaining participants
       -> [(Int, DecShare)]
    go _ []         = []
    go i ((k,n):ps) = case HM.lookup k shares of
        Nothing -> go (i + n) ps
        Just ss -> zip [i..] (take n ss) ++ go (i + n) ps

-- CHECK: @verifyEncShare
-- | Verify encrypted shares
verifyEncShares
    :: MonadRandom m
    => SecretProof
    -> Scrape.Threshold
    -> [(VssPublicKey, EncShare)]
    -> m Bool
verifyEncShares SecretProof{..} threshold pairs
    | threshold <= 1     = error "verifyEncShares: threshold must be > 1"
    | threshold >= n - 1 = error "verifyEncShares: threshold must be < n-1"
    | otherwise =
          Scrape.verifyEncryptedShares
              spExtraGen
              threshold
              spCommitments
              spParallelProofs
              (coerce $ map snd pairs)  -- shares
              (coerce $ map fst pairs)  -- participants
  where
    n = fromIntegral (length pairs)

-- CHECK: @verifyShare
-- | Verify that DecShare has been decrypted correctly.
verifyDecShare :: VssPublicKey -> EncShare -> DecShare -> Bool
verifyDecShare (VssPublicKey pk) (EncShare es) (DecShare sh) =
    Scrape.verifyDecryptedShare (es, pk, sh)

-- CHECK: @verifySecretProof
-- | Verify that SecretProof corresponds to Secret.
verifySecret :: SecretProof -> Secret -> Bool
verifySecret SecretProof{..} (Secret secret) =
    Scrape.verifySecret spExtraGen spCommitments secret spProof
